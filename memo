int main(int argc, char *argv[])
{
    if (argc <= 2) {
        if (argc  < 2) {
            printf("Too few arguments\n");
            exit(1);
        }
        if (!(strcmp(argv[1], "-help")) || !(strcmp(argv[1], "-h"))) execlp("cat", "cat", "HELP", NULL);
        else {
            printf("Bad arguments\n");
            exit(1);
        }
    }

    int mode = 0; 
    if (!(strcmp(argv[1], "-e")) || !(strcmp(argv[1], "-encrypt"))) {
        mode = 0;
    } else if (!(strcmp(argv[1], "-d")) || !(strcmp(argv[1], "-decrypt"))) {
            mode = 1;
    } else {
        printf("Bad arguments\n");
        exit(1);
    }
    unsigned char *block = calloc(block_size, sizeof(unsigned char));
    unsigned char *key = calloc(key_size, sizeof(unsigned char));
    unsigned char *left = calloc(block_size / 2, sizeof(unsigned char));
    unsigned char *right = calloc(block_size / 2, sizeof(unsigned char));
    unsigned char *cf = NULL;
    unsigned char *new_left = calloc(block_size / 2, sizeof(unsigned char));
    unsigned char **keys;
    unsigned char *p = NULL;
    char *str;
    int i, rc = 0, wc = 0, last_rc = 0;
    long x = 0;
    int fd1 = open(argv[2], O_RDONLY), fd2 = open(argv[3], O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd1 == -1 || fd2 == -1) {
        printf("Bad file name\n");
        exit(1);
    }
    char c[3], *eptr = NULL;
    str = getstr();
    str[2 * key_size] = '\0';
    for (i = 0; i < key_size * 2; i+=2) {
        c[0] = str[i];
        c[1] = str[i + 1];
        c[2] = '\0';
        x = strtol(c, &eptr, 16);
        if (*eptr != '\0') {
            printf("Bad key\n");
            exit(1);
        }
        key[i / 2] = (unsigned char)x;
    }
    keys = keygen(key, rounds);
    memset(block, '\n', block_size);
    p = block;
    while ((rc = read(fd1, p, block_size - rc)) > 0) {
            p+=rc;
            if (rc == block_size) {
                if (mode == 0) {
                    cryptb(block, keys, left, right, cf, new_left);
                } else decrypt(block, keys, left, right, cf, new_left);
                p = block;
                wc =0;
                while ((wc = write(fd2, p, block_size - wc)) > 0) {
                    p+=wc;
                    if (wc == block_size) {
                        p = block;
                        rc = 0;
                        memset(block, '\n', block_size);
                        break;
                    }
                }
            }
            last_rc = rc; 
    }
    if (last_rc != 0) {
        if (mode == 0) {
            cryptb(block, keys, left, right, cf, new_left);
        } else decrypt(block, keys, left, right, cf, new_left);
        p = block;
        wc = 0;
        while ((wc = write(fd2, p, block_size - wc)) > 0) {   
            p+=wc;
            if (wc == block_size) break;
        }
    }

    free_arr(&block);
    free_arr(&left);
    free_arr(&right);
    free_arr(&key);
    free_arr(&cf);
    free_arr(&new_left);
    if (str) {
        free(str);
        str = NULL;
    }
    for (i = 0; i < rounds; i++) {
        if (keys[i]) free(keys[i]);
    }
    if (keys) {
        free(keys);
        keys = NULL;
    }
    close(fd1);
    close(fd2);
    printf("\n");
    return 0;
}